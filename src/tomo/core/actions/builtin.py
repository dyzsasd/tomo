# pylint: disable=C0301
# Line too long
from dataclasses import field
import logging
import time
import typing

from tomo.core.events import BotUttered, UserUttered, SlotSet, SlotUnset
from tomo.nlu.models import Entity
from tomo.shared.action import Action
from tomo.core.events.base import Event
from tomo.shared.output_channel import OutputChannel
from tomo.core.session import Session


logger = logging.getLogger(__name__)


class ActionListen(Action):
    name: typing.ClassVar[str] = "listen"
    description: typing.ClassVar[str] = (
        "The ActionListen action is used to indicate that the bot is waiting for further input from the user. This action is typically chosen when:"
        "1.	The bot has asked the user a question and is awaiting a response."
        "2.	The bot has already provided a reply (via a bot_utter action), and there is no additional information to provide until the user responds."
        "This ensures that the bot transitions into a listening state to allow the user to continue the conversation or provide the needed details to "
        "proceed. It plays a critical role in maintaining the flow of multi-turn conversations, ensuring the bot does not prematurely take further actions "
        "before the user has had the chance to reply."
    )

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        pass


class ActionReinitializeSlot(Action):
    name: typing.ClassVar[str] = "reinitialize_slot"
    description: typing.ClassVar[
        str
    ] = "Reset all the slot in the value, happens when to reinitialize the session."

    slots: typing.List[str] = field(
        metadata={"description": "Slot name which need to be initialized"}
    )

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        return [
            SlotUnset(
                key=slot,
                timestamp=time.time(),
                metadata=None,
            )
            for slot in self.slots
        ]


class ActionBotUtter(Action):
    name: typing.ClassVar[str] = "bot_utter"
    description: typing.ClassVar[
        str
    ] = "Send a message to user for reply or for asking a question."

    message: str = field(
        metadata={"description": "Message which will be sent to User."}
    )

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        await output_channel.send_text_message(self.message)
        return [
            BotUttered(
                text=self.message,
                data=None,
                timestamp=time.time(),
                metadata=None,
            )
        ]


class ActionBotUtterQuickReply(ActionBotUtter):
    name: typing.ClassVar[str] = "bot_utter_quick_reply"
    description: typing.ClassVar[
        str
    ] = "A special action of ActionBotUtter, in future, the message should be generated by NLG."

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        if not session.has_bot_replied():
            await output_channel.send_text_message(self.message)
            logger.debug(f"Quick {self.message} reply has been sent.")
            return [
                BotUttered(
                    text=self.message,
                    data=None,
                    timestamp=time.time(),
                    metadata=None,
                )
            ]
        return []


class ActionExtractSlots(Action):
    name: typing.ClassVar[str] = "extract_slots"
    description: typing.ClassVar[
        str
    ] = "Extract the slot value from entities and decide if it should be set."

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        user_uttered: UserUttered = session.last_user_uttered_event()

        if user_uttered is None or not isinstance(user_uttered, UserUttered):
            return []

        events = []
        new_entities: typing.List[Entity] = user_uttered.entities or []
        for entity in new_entities:
            if entity.name not in session.slots:
                logger.warning(
                    f"Extracted entity {entity.name} are not in session's defined slots"
                )
                continue
            if entity.replace is None or entity.replace:
                logger.debug(f"Generating SlotSet event of {entity.name}")
                events.append(
                    SlotSet(
                        key=entity.name,
                        value=entity.value,
                        timestamp=time.time(),
                        metadata=None,
                    )
                )
            else:
                logger.debug(f"{entity} won't be setted.")
        return events


class ActionSessionStart(Action):
    name: typing.ClassVar[str] = "session_start"
    description: typing.ClassVar[
        str
    ] = "Start the session by sending a greet message to user."

    greeting_message: str = field(
        metadata={"description": "Message which will be sent to User"}
    )

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        await output_channel.send_text_message(self.greeting_message)
        return [
            BotUttered(
                text=self.greeting_message,
                data=None,
                timestamp=time.time(),
                metadata=None,
            )
        ]


class ActionDisableSession(Action):
    name: typing.ClassVar[str] = "disable_session"
    description: typing.ClassVar[str] = "Turn off the session immediately"
    "Turn off action"


class ActionUpdateStep(Action):
    name: typing.ClassVar[str] = "update_step"
    description: typing.ClassVar[
        str
    ] = "Updates the 'step' slot to indicate the current step in the workflow."

    step_name: str = field(
        metadata={
            "description": "The name of the current step to be set in the 'step' slot."
        }
    )

    async def run(
        self, output_channel: OutputChannel, session: Session
    ) -> typing.Optional[typing.List[Event]]:
        logger.debug(f"Updating step to: {self.step_name}")
        return [
            SlotSet(
                key="step",
                value=self.step_name,
                timestamp=time.time(),
                metadata=None,
            )
        ]
